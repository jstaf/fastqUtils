#!/usr/bin/env python3

import sys
import os
import re
import gzip
import argparse

from fqutils.fastq import Fastq
import fqutils.util as util

def main():
    parser = argparse.ArgumentParser(
            description='Re-pair reads from discordant FASTQ files (for instance, after filtering reads by quality).')
    parser.add_argument('-v', '--version', action='version', version='fq-repair version 1.0')
    parser.add_argument('-u', '--keep-unique', default=False, const=True, action='store_const',
            help='Keep reads without a corresponding match. Unique reads are output to a separate file (filename_unique.fastq).')
    parser.add_argument('-1', '--output1', nargs=1, type=str,
            help='Output for first FASTQ file after re-pairing (defaults to "filename_common.fastq"). May be gzipped.')
    parser.add_argument('-2', '--output2', nargs=1, type=str,
            help='Output for second FASTQ file after re-pairing (defaults to "filename_common.fastq"). May be gzipped.')
    parser.add_argument('fastq1', nargs=1, type=str,
            help='First FASTQ file to be re-paired.')
    parser.add_argument('fastq2', nargs=1, type=str,
            help='Second FASTQ file to be re-paired.')
    argv = parser.parse_args()

    fq1 = argv.fastq1
    fq2 = argv.fastq2



def index(list_of_fastqs):
    """
    Create a dictionary of readids and their seek positions.
    """
    
    idx = {}
    for filename in list_of_fastqs:
        file_idx = {}
        with Fastq(filename) as fq:
            while True:
                read, pos = fq.get_read()
                if read is None:
                    break
                else:
                    file_idx[read[0]] = pos
        idx[filename] = file_idx
    return idx


def matchReads(fastq1, fastq2):
    idx = index(fastq2)

    # input file handles
    fastq1_orig = [Fastq(fname) for fname in fastq1]
    fastq2_orig = [Fastq(fname) for fname in fastq2]

    # output file handles
    fastq1_common = Fastq(util.prefix_extension(fastq1, '_common'), 'w')
    fastq1_unique = Fastq(util.prefix_extension(fastq1, '_unique'), 'w')
    fastq2_common = Fastq(util.prefix_extension(fastq2, '_common'), 'w')

    while True:
        read1, pos = fastq1_orig.nextRead()
        if read1 is None:
            break
        readid = read1[0]
        if readid in idx.keys():
            # write both reads out to common files, remove key from index
            fastq1_common.write(read1)
            fastq2_orig.file.seek(idx.pop(readid))
            read2, pos = fastq2_orig.nextRead()
            fastq2_common.write(read2)
        else:
            # write out to unique file for fastq1
            fastq1_unique.writelines(read1)
    # close file handles
    fastq1_common.close()
    fastq1_unique.close()
    fastq2_common.close()

    # all remaining keys in dictionary are the unique reads for fastq2
    with open(fastq2 + '.unique', 'w') as fastq2_unique:
        for remaining in idxStore:
            fastq2_parser.file.seek(idxStore[remaining])
            read = fastq2_parser.nextRead()
            fastq2_unique.writelines([read['header'], read['bases'], read['qheader'], read['quals']])
    fastq1_parser.close()
    fastq2_parser.close()
    return

if __name__ == '__main__':
    main()

